---
title: Unity笔记从0-1
date: 2024-12-08 11:48:47
tags:
---
# 图像学需要学什么

# 如何快速成长为图形学工程师

图形学作为计算机科学的一个分支，主要研究计算机生成和处理图像、视觉效果的技术。图形学工程师在游戏开发、影视特效、虚拟现实等领域具有广泛的应用。本文将为你提供一条快速成长为图形学工程师的途径，详细介绍相关学习方法、实践案例和求职建议。

一、图形学工程师简介

图形学工程师主要负责设计和实现图形渲染算法、优化图形性能、处理图像数据等任务。

他们需要具备扎实的数学、物理知识，熟悉计算机图形学原理，掌握图形编程语言（如 OpenGL、DirectX、Vulkan）以及常用的图形引擎（如 Unity、Unreal Engine）。

二、快速成长路径

**打牢基础**

图形学工程师需要具备一定的数学、物理和计算机科学基础。建议从以下几个方面开始学习：

数学：向量、矩阵、几何变换、微积分等；

物理：光学、力学、电磁学等；

计算机科学：数据结构、算法、计算机图形学基本原理。

**学习图形编程语言**

熟练掌握图形编程语言是图形学工程师的基本技能。常见的图形编程语言有 OpenGL、DirectX 和 Vulkan。可以从简单的 2D 图形绘制开始，逐步学习 3D 渲染、纹理贴图、光照计算等高级技术。

以 OpenGL 为例，首先学习如何创建一个 OpenGL 上下文，并绘制一个简单的三角形：

\#include <GL/glut.h>

void display() {

 glClear(GL_COLOR_BUFFER_BIT);

 glBegin(GL_TRIANGLES);

 glColor3f(1.0, 0.0, 0.0);

 glVertex2f(0.0, 0.5);

 glColor3f(0.0, 1.0, 0.0);

 glVertex2f(-0.5, -0.5);

 glColor3f(0.0, 0.0, 1.0);

 glVertex2f(0.5, -0.5);

 glEnd();

 glFlush();

}

int main(int argc, char **argv) {

 glutInit(&argc, argv);

 glutCreateWindow("Hello Triangle");

 glutDisplayFunc(display);

 glutMainLoop();

 return 0;

}

**掌握图形引擎**

为了提高开发效率，图形学工程师通常会使用图形引擎进行开发。常用的图形引擎有 Unity、Unreal Engine、Godot 等。

学习图形引擎的使用方法，掌握其编程模型和渲染管线。

以 Unity 为例，可以从创建一个简单的 3D 场景开始，逐步学习光照、材质、动画、特效等技术。以下是一个简单的 Unity 脚本，用于使物体旋转：

using UnityEngine;

public class RotateObject : MonoBehaviour {

 public float speed = 50.0f;

 void Update() {

   transform.Rotate(Vector3.up, speed * Time.deltaTime);

 }

}

**实践项目经验**

积累实际项目经验对图形学工程师的成长至关重要。可以参与开源项目、个人项目或实习，实际解决图形学相关问题。例如：

开发一个简单的 3D 游戏或应用；

实现一个光线追踪渲染器；

优化现有图形算法，提高渲染性能。

**深入学习和研究**

为了成为图形学领域的专家，建议深入学习和研究图形学相关理论和技术，阅读经典教材、学术论文和博客文章。例如：

《计算机图形学》（Fundamentals of Computer Graphics）；

《实时渲染》（Real-Time Rendering）；

SIGGRAPH 会议论文。

三、求职建议

在求职过程中，以下建议可能对你有所帮助：

完善作品集：制作一个在线作品集，展示你的项目经验和技术能力。包括游戏开发、渲染算法、性能优化等方面的实际成果。

网络拓展：参加行业活动、技术论坛，结识图形学领域的同行。保持与同行的沟通和交流，获取最新的行业动态和招聘信息。

准备面试：准备好图形学、数学、物理、编程等方面的面试题，以展示你的专业能力。掌握面试技巧，自信地表达你的思路和解决方案。

四、总结

图形学工程师是一个充满挑战和乐趣的职业。通过打牢基础、学习图形编程语言、掌握图形引擎、积累实践经验和深入研究，你将能够快速成长为一名优秀的图形学工程师。

在成长过程中，保持好奇心、热情和毅力，不断学习新技术，提升自己的技能水平。

随着科技的发展，图形学在虚拟现实、增强现实、机器学习等领域的应用越来越广泛。掌握跨领域知识，拓宽自己的技能边界，将有助于你在职业生涯中取得更大的成功。

希望本文能为你提供一个清晰的图形学工程师成长路径，帮助你实现职业目标。祝你在图形学领域取得丰硕的成果，成为行业内的佼佼者！

# 图形学基础

## 闫令琪课程笔记

### 第三节课 Transformer

上节回顾

![image-20241116192625201](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116192625201.png)

变换的分类：模型变换、模型变换 

![image-20241116192805029](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116192805029.png)

什么是变换：从三维空间到二维空间的变化，称为投影

![image-20241116193029122](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193029122.png)

第一：缩放变换

![image-20241116193151162](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193151162.png)

矩阵形式表示

![image-20241116193312153](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193312153.png)

x和y不相同的变换

![image-20241116193425806](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193425806.png)

反射变换

![image-20241116193847096](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193847096.png)



矩阵形式

![image-20241116193912884](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116193912884.png)

切变

![image-20241116194209988](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116194209988.png)

只有水平坐标发生了变化，同时在斜边上的每一个点的变换和y的位置有关，比如在中间就是移动了a/2

所以表示成矩阵的形式

![image-20241116194558839](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116194558839.png)

旋转（一般默认绕原点，逆时针）

![image-20241116194813158](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116194813158.png)

表示成矩阵

![image-20241116195636977](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116195636977.png)

该矩阵可以通过特殊到一般的推导过程

![image-20241116195716333](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116195716333.png)

代入左上角的点，可以求出其余的值

线性变换可以表示成矩阵

该过程统称为线性变换

![image-20241116195940702](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116195940702.png)

 

#### 齐次坐标

主要用于平移变换

![image-20241116200237734](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116200237734.png)

表示成矩阵形式

一般思维，这样表示就和之前的表示方式不统一

![image-20241116200411797](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116200411797.png)

如何统一的表示呢？

可以通过齐次坐标表示

具体步骤

增加一个维度

![image-20241116200709717](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116200709717.png)

为什么点和向量处理方式不同

向量具有平移不变性，所以为了保证这个性质，所以加一个零

更深层的意义，在二维的空间中，保证在平移之后，意义不变，矩阵相加最后任然为0，满足性质

点相互减，最后一个任然为零，且结果为矩阵，所以任然有意义



![image-20241116202058130](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116202058130.png)

那么最后一个结果如何呢，这里 有新的定义

可以同时除以W,任然保证他是一个点，所以根据上面的定义，在齐次坐标中，一个点加上另一个点得到的结果是一个在两者中间的一个点

![image-20241116202605928](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116202605928.png)

仿射变换都可以协程齐次坐标的方式

![image-20241116202923778](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241116202923778.png)

从上面可以看出来的特点

最后一行都为001，最后一列前两个数为平移，abcd表示线性变换（只是在仿射变换中有）

总结：

![image-20241117111533195](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117111533195.png)

#### 逆变换

概念：也就是一个变换都对应一个逆变换，存在对应关系

![image-20241117112137746](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117112137746.png)

变换过程

![image-20241117112212709](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117112212709.png)

变换的顺序很重要

也就是矩阵不具有交换律

一般的情况下，对向量进行变换，向量会放在最后

![image-20241117112425631](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117112425631.png)

上述过程，先是进行旋转，然后整体进行平移

顺序如下



![image-20241117113217728](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117113217728.png) 

通过一个3x3的矩阵可以表示很多种不同的操作

变换可以合成，也可以分解

对于绕非原点旋转的情况

![image-20241117113910500](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117113910500.png)

可以处理成平移（-c）---》旋转---》平移(c)

> 这里需要注意的是，第一个操作要距离向量最近



#### 3DTransforms

线性变换

![image-20241117114133867](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117114133867.png)

在三维坐标下面表示的点为（x,y,z均除以w）

![image-20241117114344012](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117114344012.png)

三维齐次

![image-20241117114433793](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117114433793.png)

那么接下来有一个问题？

**在写成这种综合的矩阵，那么到底是先平移还是先线性变换呢**

 答案：通过下面的式子，可知道是先线性变换

![image-20241117114713570](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20241117114713570.png)

# shader

**什么是shader？**

shader，翻译为着色器，可以将材质理解为画板，shader相当于一个颜料，用于上颜色。

shader是可编程图形管线的代码片段。

**分类：**vertex shader(顶点shader),fragment shader（片段shader）

**什么是渲染管线？**

可以理解为很多个shader放在一起，如同多个独立的流水线，按照某种规定执行，次序执行

![image-20240324194219622](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20240324194219622.png)

**shader 流程图**

![image-20240324194614560](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324194614560.png)

**对于图片中运行过程的解释**

这张图展示了3D应用程序或游戏的渲染过程，主要分为CPU和GPU的协作。以下是每个过程的详细解释：

1. **3D应用程序或游戏**：

   - 用户通过3D应用程序或游戏进行交互，输入指令和操作。

2. **3D应用接口（OpenGL / DirectX）**：

   - 这些是图形API（应用程序接口），用于与GPU进行通信。它们提供了一组函数，允许开发者控制图形硬件，进行渲染操作。

3. **CPU与GPU分界**：

   - CPU（中央处理器）负责处理游戏逻辑、物理计算和其他非图形相关的任务，而GPU（图形处理器）专注于图形渲染。

4. **GPU前段模块**：

   - 负责接收来自CPU的数据，并进行初步处理。

5. **顶点着色器**是图形渲染管线中的一个重要阶段，主要负责对每个顶点进行处理。它的主要作用包括以下几个方面：

   1. **顶点位置转换**：
      - 顶点着色器将顶点的局部坐标转换为裁剪坐标。这个过程通常包括将顶点从模型空间（object space）转换到世界空间（world space），然后再转换到观察空间（view space）和最终的裁剪空间（clip space）。这些转换通常涉及矩阵乘法。

   2. **光照计算**：
      - 顶点着色器可以进行基础的光照计算，根据光源的方向和性质计算顶点的光照值。这有助于生成对象的基本阴影和高光效果。

   3. **顶点属性处理**：
      - 顶点着色器可以接收并输出与每个顶点相关的各种属性，包括法线（用于光照计算）、纹理坐标（用于纹理映射）、颜色等。这些属性将在后面的渲染阶段（例如片段着色器）中使用。

   4. **传递数据到后续阶段**：
      - 顶点着色器的输出通常是传递到光栅化阶段的插值数据，这些数据对之后的片段着色器进行进一步处理。因此，顶点着色器的输出必须包含必要的信息，以确保后面的光栅化和片段处理可以准确完成。

   5. **支持实例化渲染**：
      - 在需要绘制多个相同的对象时，顶点着色器可以利用实例化技术，减少冗余计算。通过每个实例传递不同的属性，使得渲染性能得以提升。

   总之，顶点着色器的重要性在于它为渲染管线的后续阶段提供了必要的顶点处理与信息传递，同时为基本的光照和几何变换提供了支持。

6. **图元装配**：

   - 将顶点数据（如位置、颜色、纹理坐标等）组合成图元（如三角形、线段等），为后续的光栅化做准备。

7. **光栅化及插值**：

   - 将图元转换为像素（光栅化），并在像素之间进行插值计算，以确定每个像素的颜色和深度值。

     > 光栅化是计算机图形学中的一个关键过程，它负责将几何图形（通常是图元，如三角形）转换为像素（或片段），以便在显示设备上呈现。光栅化通常发生在图形渲染管线中，位于顶点着色器与片段着色器之间。
     >
     > ### 光栅化的主要过程包括：
     >
     > 1. **图元生成**：
     >    - 在光栅化开始前，顶点着色器输出的顶点数据被用来生成图元（例如三角形）。每个三角形由三个顶点以及与这些顶点相关的属性（如位置、颜色、纹理坐标等）组成。
     >
     > 2. **确定覆盖像素**：
     >    - 光栅化的核心任务是确定图元覆盖了哪些像素。三角形内部的像素被视为覆盖了这个图元。光栅化算法会检查每个像素的屏幕空间坐标，并确定它们是否落在三角形的范围内。
     >
     > 3. **插值计算**：
     >    - 对于确定为覆盖的像素，光栅化过程将对顶点属性进行插值，计算这些像素的最终属性。例如，如果三角形的顶点具有不同的颜色或纹理坐标，光栅化过程将计算在像素位置处的颜色和纹理坐标值。
     >
     > 4. **生成片段**：
     >    - 每个覆盖的像素会被转换为一个片段。片段不仅包含色彩信息，还可能包含深度值（用于深度测试）和其他与纹理和光照相关的信息。
     >
     > 5. **输出到片段着色器**：
     >    - 生成的片段将被传递到片段着色器进行进一步处理，片段着色器为每个片段进行颜色计算和效果应用，如纹理映射和光照计算。
     >
     > ### 光栅化的特点：
     >
     > - **效率高**：光栅化是一种高效的渲染技术，特别适合于实时渲染，如视频游戏和交互式应用。
     > - **图元处理**：光栅化能够处理大量的图元，并根据视口和显示器的分辨率进行调整。
     > - **空间分辨率**：最终的输出质量受到光栅化阶段的影响，特别是在边缘平滑和抗锯齿效果方面。
     >
     > 总之，光栅化是将几何图形转化为显示设备可呈现图像的关键步骤，是现代计算机图形学中不可或缺的重要技术。

8. **像素运算**：

   - 对每个像素进行进一步的处理，包括光照计算、纹理映射等，以生成最终的图像。

9. **片段着色器**：

   - 负责对每个片段（像素）进行着色，应用光照和纹理等效果，生成最终的颜色值。

10. **帧缓冲**：

   - 将处理后的图像数据存储在帧缓冲中，准备显示到屏幕上。

11. **输出到显示器**：

    - 最终的图像从帧缓冲中读取并输出到显示器，用户可以看到渲染的结果。

    - **最终的图像从帧缓冲中读取并输出到显示器的操作主要是由GPU完成的。**在图形渲染流程中，GPU负责处理所有与图像生成相关的任务，包括光栅化、片段着色和帧缓冲的管理。

      虽然CPU在整体应用程序中负责执行游戏逻辑、物理计算和调用图形API等，但在将最终的图像显示到屏幕上之前，GPU会将图像数据存储在帧缓冲中。然后，显示器通过GPU直接读取帧缓冲中的数据并显示出来。

      总结来说，**最终图像的读取和输出到显示器主要是由GPU来完成，而CPU在这个过程中并不参与具体的图像输出操作。**

这个过程展示了现代3D图形渲染的复杂性和高效性，CPU和GPU的协作使得实时渲染成为可能。



> 其中片段着色器属于可以编辑的代码片段
>
> 像素运算决定显示最终的颜色

![image-20240324194916584](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324194916584.png)

graphics API为调用硬件的接口，用于实现底层交互，如果没有这个api实现起来将会很困难

**流程图**

![image-20240324195336320](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324195336320.png)

> transform表示位置的变换，·
>
> texgen表示纹理渲染，lighting用于调整关照，因为显卡的发展，该功能被整合到vertexshader中，但是可编辑程度小于原来的。
>
> culing depth test表示深度，其作用在于将看不到的面不渲染，较少开销，提高性能。
>
> texturing表示纹理采样，用于决定每一个像素的颜色。
>
> fog表示雾化处理，可以模拟现实场景中的雾。alphatext用于处理透明度。
>
> blending用于混合处理，得到最终的图像
>
> 这个图展示了图形渲染管线中的几个关键步骤。以下是每个过程的详细解释及其原理：
>
> ### 1. 顶点着色器（Vertex Shader）
>
> - **功能**：负责对每个顶点进行处理，包括坐标变换、纹理坐标生成和光照计算。
> - **原理**：
>   - **变换**：将顶点从模型空间转换到世界空间、视图空间和裁剪空间，通常使用矩阵乘法。
>   - **纹理坐标生成（TexGen）**：计算纹理坐标，以便在后续阶段进行纹理映射。
>   - **光照计算**：根据光源的位置和性质计算顶点的光照值，为后续的片段着色器提供基础。
>
> ### 2. 剔除（Culling）
>
> - **功能**：剔除那些不在视野内的图元，以提高渲染效率。
> - **原理**：
>   - **背面剔除**：通过判断图元的法线方向与视点的关系，剔除背对摄像机的图元。
>   - **视锥剔除**：检查图元是否在视锥体内，只有在视锥体内的图元才会被进一步处理。
>
> ### 3. 深度测试（Depth Test）
>
> - **功能**：确保在渲染过程中正确处理图元的深度关系，避免不必要的重叠。
> - **原理**：
>   - 每个片段都有一个深度值，表示其距离摄像机的远近。深度测试会比较当前片段的深度值与帧缓冲中的深度值，只有当前片段的深度值更小（即更靠近摄像机）时，才会更新颜色和深度缓冲。
>
> ### 4. 片段着色器（Fragment Shader）
>
> - **功能**：对每个片段进行处理，包括纹理映射、雾效等。
> - **原理**：
>   - **纹理映射（Texturing）**：根据片段的纹理坐标从纹理中获取颜色值，并将其应用到片段上。
>   - **雾效（Fog）**：根据片段的深度值计算雾的影响，调整片段的颜色以模拟远处物体的模糊效果。
>
> ### 5. Alpha 测试（Alpha Test）
>
> - **功能**：根据片段的透明度值决定是否渲染该片段。
> - **原理**：
>   - 每个片段都有一个 alpha 值（透明度），通过与预设的阈值比较，决定该片段是否被渲染。如果 alpha 值低于阈值，则该片段将被丢弃。
>
> ### 6. 混合（Blending）
>
> - **功能**：将当前片段的颜色与帧缓冲中的颜色进行混合，以实现透明效果。
> - **原理**：
>   - 根据 alpha 值和混合方程（如源颜色和目标颜色的加权平均），计算最终的颜色值。混合操作通常用于处理半透明物体的渲染。
>
> ### 总结
>
> 这个渲染管线的每个步骤都是为了确保最终图像的质量和渲染效率。通过顶点着色器进行初步处理，剔除不必要的图元，深度测试确保正确的图层关系，片段着色器进行细节处理，最后通过 alpha 测试和混合实现透明效果，形成最终的渲染结果。

**shader和材质、贴图之间的关系**

 shader相当于一段程序，算法。负责将输入的顶点数据以指定的方式和输入的贴图或者颜色组织在一起，然后输出。绘图单元可以根据这个输出来将图像绘制在屏幕上。输入的贴图、颜色，加上shader，以及shader的相关参数打包存储在一起就得到一个材质，材质相当于一个整合人员，将这些物品组合在一起。从而通过材质可以实现物品的渲染。材质好比最终的商品，shader相当于加工方法，贴图就是原材料。但是原材料不知贴图。（可以理解为一个人（**material**）通过某些手段（**shader**）以及材料(**贴图)**，让自己变好看）

**总结：**

![image-20240324200747765](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324200747765.png)

 **编写shader可以选择掌握的几门语言**

![image-20240324201614795](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324201614795.png)



![image-20240324201729040](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324201729040.png)

OPENGL简介

![image-20240324202036119](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324202036119.png)

![image-20240324202307636](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324202307636.png)

![image-20240324202601161](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324202601161.png)

 ![image-20240324205146090](D:\DeskTop\FileSum\UnityClassResources\笔记\image-20240324205146090.png)



# [shader里的uv是什么](https://www.cnblogs.com/sdycxxl2010/p/12641145.html)

整的说，其实应该是UVW（因为XYZ已经用过了，所以另选三个字母表示）。U和V分别是图片在显示器水平、垂直方向上的坐标，取值一般都是0~1，也 就是（水平方向的第U个像素/图片宽度，垂直方向的第V个像素/图片高度）

UV” 这里是指u,v纹理贴图坐标的简称(它和空间模型的X, Y, Z轴是类似的). 它定义了图片上每个点的位置的信息.

